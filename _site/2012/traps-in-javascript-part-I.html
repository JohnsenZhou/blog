<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
    <link href="http://gmpg.org/xfn/11" rel="profile">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>JavaScript 中的一些坑（一） - Johnsen</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	
	<link rel="canonical" href="http://localhost:4000/2012/traps-in-javascript-part-I">
	<link rel="alternate" type="application/rss+xml" title="Subscribe Feed" href="/feed.xml">
	<link  href="/css/app.css" rel="stylesheet" media="all">
	<link href="//cdn.bootcss.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- <link href='//fonts.useso.com/css?family=PT+Serif:400,700' rel='stylesheet' type='text/css'> -->
	<script>
	// function loadSync(u,p,a){
	// 	if(!p && location.port)return {onload: null};
	// 	if(/\.js$/.test(u)){a='script'}else{a='link'};
	// 	var d=document,s=d.createElement(a),f=d.getElementsByTagName(a)[0];
	// 	if(a=='link'){s.href=u,s.rel='stylesheet'}else{s.src=u,s.async=true}
	// 	f.parentNode.insertBefore(s,f);return s;
	// }
	// var _gaq = _gaq || [];
	// _gaq.push(['_setAccount', 'UA-15720258-1']);
	// _gaq.push(['_trackPageview']);
	// _gaq.push(['_trackPageLoadTime']);
	// loadSync('//ssl.google-analytics.com/ga.js');
	// if(/windows/i.test(navigator.userAgent)){document.getElementsByTagName('html')[0].className = 'windows'}
    </script>
    <!--[if lt IE 9]>
    <script>window.location.href="http://browsehappy.com"</script>
    <![endif]-->
</head>

<body>

<header id="header" role="banner">
	<div class="header-inner">
	
		<a href="/" class="blog-title home">Johnsen</a>
		<div>
	<a href="//github.com/JohnsenZhou" class="social-link">
		<i class="fa fa-github"></i>
	</a>
</div>
	
	</div>
	<a href="/feed.xml" data-tip="true" data-tip-content="订阅" class="tip--top subscribe">
		<i class="fa fa-rss"></i>
	</a>
</header>

<main class="fluid" role="main">
  <article class="post" role="article">
    <header class="post-header">
      <h1 class="post-title">JavaScript 中的一些坑（一）</h1>
    </header>
    <section class="post-content">
      <p>“坑”这个字，在此的意思是“陷阱”。由于 JavaScript “弱语言”的性质，使得其在使用过程中异常的宽松灵活，但也极为容易“中招”。</p>

<h2>坑一：全局变量</h2>

<blockquote>
<p>JavaScript 通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p>
</blockquote>

<p>“未声明直接简单使用”，指的是不用 <code>var</code> 关键字来声明变量。这个我们已经非常清楚，避免造成隐式产生全局变量的方法就是声明变量尽量用 <code>var</code> 关键字。</p>

<p>可你以为用了 <code>var</code> 就 ok 了？来看看这个坑：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// body...</span>
<span class="p">}</span>
</code></pre></div>
<p>也许你期望得到的是两个局部变量，但 <code>b</code> 却是货真价实的全局变量。why? Because <strong>赋值运算是自右往左的</strong>，所以这相当于：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">(</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// body...</span>
<span class="p">}</span>
</code></pre></div>
<p>所以 <code>b</code> 是全局变量。</p>

<p>填坑：变量声明，最好一个个来，别搞批发~_~;</p>

<h2>坑二：变量声明</h2>

<p>先来看坑：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">myName</span> <span class="o">=</span> <span class="s2">"global"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">myName</span> <span class="o">=</span> <span class="s2">"local"</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>
</code></pre></div>
<p>乍看上去，我们预计期望两次 <code>alert</code> 的结果分别为 &ldquo;global&rdquo; 与 &ldquo;local&quot;，但真实的结果是 &quot;undefined&rdquo; 与 &ldquo;local&quot;。why? 因为：</p>

<blockquote>
<p>变量在同一作用域（同一函数）中，声明都是被提至作用域顶部先进行解析的。</p>
</blockquote>

<p>所以以上代码片段的执行行为可能就像这样：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">myName</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// "undefined"</span>
    <span class="nx">myName</span> <span class="o">=</span> <span class="s2">"local"</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// "local"</span>
<span class="p">}</span>
</code></pre></div>
<p>用另一个坑来测试下你是否真的理解了预解析：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">"a"</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</code></pre></div>
<p><code>a</code> 变量的声明被提前到了代码顶端，此时还未赋值。接下来进入 <code>if</code> 语句，判断条件中 <code>&quot;a&quot; in window</code> 已成立（<code>a</code> 已被声明为全局变量），所以判断语句计算结果为 <code>false</code>，直接就跳出 <code>if</code> 语句了，所以 <code>a</code> 的值为 <code>undefined</code>。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// "undefined"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"a"</span> <span class="k">in</span> <span class="nb">window</span><span class="p">);</span> <span class="c1">// true</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">"a"</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 不执行</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// "undefined"</span>
</code></pre></div>
<p>填坑：变量声明，最好手动置于作用域顶部，对于无法当下赋值的变量，可采取先声明后赋值的手法。</p>

<h2>坑三：函数声明</h2>

<blockquote>
<p>函数声明也是被提前至作用域顶部，先于任何表达式和语句被解析和求值的</p>
</blockquote>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span> <span class="c1">// "function"</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// body...</span>
<span class="p">}</span>
</code></pre></div>
<p>可以对比一下：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span> <span class="c1">// "undefined"</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// body...</span>
<span class="p">};</span>
</code></pre></div>
<p>明白了这个道理的你，是否还会踩以下的坑呢？</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">"1"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">test</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">"2"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">test</span><span class="p">();</span>
</code></pre></div>
<p>运行以上代码片段，看到的两次弹窗显示的都是 &quot;2&quot;，为什么不是分别为 &quot;1&rdquo; 和 &ldquo;2&rdquo; 呢？很简单，<code>test</code> 的声明先于 <code>test()</code> 被解析，由于后者覆盖前者，所以两次执行的结果都是 &ldquo;2&quot;。</p>

<p>填坑：多数情况下，用函数表达式来代替函数声明是一个好习惯，特别是在一些语句块中。</p>

<h2>坑四：函数表达式</h2>

<p>先看命名函数表达式，理所当然，就是它得有名字，例如：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// body...</span>
<span class="p">};</span>
</code></pre></div>
<p>要注意的是：函数名只对其函数内部可见。如以下坑：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// 正常运行</span>
<span class="p">};</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 出错：ReferenceError</span>
</code></pre></div>
<p>填坑：尽量少用命名函数表达式（除了一些递归以及 debug 的用途），切勿将函数名使用于外部。</p>

<h2>坑五：函数的自执行</h2>

<p>对于函数表达式，可以通过后面加上 <code>()</code> 立即执行。并且可在 <code>()</code> 中传递参数，而函数声明不可以。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// (1) 这只是一个分组操作符，不是函数调用！</span>
<span class="c1">// 所以这里函数未被执行，依旧是个声明</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>以下代码片段分别执行都弹窗显示 &quot;1&quot;，因为在 <code>(1)</code> 之前，都为函数表达式，所以这里的 <code>()</code> 非分组操作符，而为运算符，表示调用执行。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 标准的匿名函数表达式</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 前面的 () 将 function 声明转化为了表达式</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">})(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 整个 () 内为表达式</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// new 表达式</span>
<span class="k">new</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// &amp;&amp;, ||, !, +, -, ~ 等操作符（还有逗号），在函数表达式和函数声明上消除歧义</span>
<span class="c1">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span>
<span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}(</span><span class="mi">1</span><span class="p">);</span><span class="err">​</span>
</code></pre></div>
<p>填坑：要解决这个坑的关键在于，弄清楚形形色色的函数表达式之实质。</p>

<h2>坑六：循环中的闭包</h2>

<p>以下演示的是一个常见的坑：</p>

<iframe style="width: 100%; height: 300px" frameborder="0" seamless="seamless" src="http://jsfiddle.net/GNDd4/embedded/result,html,js/light/"></iframe>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"ul"</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"a"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">"You click link #"</span> <span class="o">+</span> <span class="nx">i</span><span class="p">);</span>        
    <span class="p">}</span>       
<span class="p">}</span>
</code></pre></div>
<p>我们预期当点击第 <code>i</code> 个链接时，得到此序列索引 <code>i</code> 的值，可实际无论点击哪个链接，得到的都是 <code>i</code> 在循环后的最终结果：&quot;5&quot;。</p>

<p>解释一下原因：当 <code>alert</code> 被调用时，<code>for</code> 循环内的匿名函数表达式，保持了对外部变量 <code>i</code> 的引用（闭包），此时循环已结束，<code>i</code> 的值被修改为 &quot;5&quot;。</p>

<p>填坑：为了得到想要的结果，需要在每次循环中创建变量 <code>i</code> 的拷贝。以下演示正确的做法：</p>

<iframe style="width: 100%; height: 300px" frameborder="0" seamless="seamless" src="http://jsfiddle.net/UTy8Z/embedded/result,html,js/light/"></iframe>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"ul"</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"a"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
            <span class="nx">alert</span><span class="p">(</span><span class="s2">"You click link #"</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>        
        <span class="p">}</span>
    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>可以看到，<code>(function () { ... })()</code> 的形式，就是上文提到的<strong>函数的自执行</strong>，<code>i</code> 作为参数传给了 <code>index</code>，<code>alert</code> 再次执行时，它就拥有了对 <code>index</code> 的引用，此时这个值是不会被循环改变的。当然，明白了道理后，你也可以这样写：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">links</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
            <span class="nx">alert</span><span class="p">(</span><span class="s2">"You click link #"</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>        
        <span class="p">}</span>
    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>It works too.</p>

    </section>
    <footer class="post-footer">
      <div class="post-meta">
        <time datetime="2012-11-29 14:47:00 +0800" class="updated" pubdate>Nov 29, 2012</time>

        
<span class="post-tag">
	
		<span class="tag">javascript</span>
	
</span>


      </div>
    </footer>
  </article>
</main>

<div class="post-comment">
	<div id="disqus_thread" class="container"></div>
</div>
<script>
function getElementTopLeft(elem) {
	var top = 0;
	var left = 0;
	while(elem) {
		top += elem.offsetTop;
		left += elem.offsetLeft;

		elem = elem.offsetParent;
	}
	return {top: top, left: left};
}

var disqus_shortname = 'roshanca';
var disqus_elem = document.getElementById('disqus_thread');
var disqus_init = false;

window.onscroll = function () {
	if (disqus_init) return;

	var viewHeight = document.documentElement.clientHeight;
	var scrollY = document.documentElement.scrollTop || document.body.scrollTop;

	if(getElementTopLeft(disqus_elem).top < viewHeight + scrollY) {
		loadSync('//' + disqus_shortname + '.disqus.com/embed.js');
		disqus_init = true;
	}
}
</script>



<footer id="footer" role="contentinfo">
	<p>© Copyright 2017 by Johnsen.</p>
</footer>

<div class="fork-github">
    <a href="https://github.com/JohnsenZhou">View on GitHub</a>
</div>

</body>
</html>
